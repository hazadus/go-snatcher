# План постепенного рефакторинга и внедрения TUI

Этот план описывает шаги по рефакторингу приложения `go-snatcher` для постепенного внедрения пользовательского интерфейса на основе библиотеки Bubble Tea.

**Ключевые цели:**
1.  Отделить бизнес-логику от ее представления (CLI или TUI).
2.  Сохранить полную работоспособность существующих CLI-команд (`add`, `list`, `play` и т.д.).
3.  Создать TUI-режим, который будет запускаться отдельной командой (`snatcher tui`).
4.  Начальная версия TUI будет включать два экрана: список треков и экран воспроизведения.

---

## Этап 1: Рефакторинг основной логики

**Цель:** Вынести логику команд `list` и `play` в отдельные "сервисы", чтобы их можно было переиспользовать как в CLI, так и в TUI.

### Задача 1.1: Рефакторинг логики списка треков

1.  **Создать сервис `track`**:
    *   Создать файл `internal/track/manager.go`.
    *   В нем определить структуру `Manager`, которая будет получать `*data.AppData` в конструкторе.
2.  **Перенести логику**:
    *   Создать в `Manager` метод `ListTracks() []data.TrackMetadata`.
    *   Этот метод должен просто возвращать `appData.Tracks`.
3.  **Обновить команду `list`**:
    *   В `cmd/snatcher/list.go` изменить функцию `listTracks`, чтобы она использовала `track.Manager` для получения списка треков, а затем форматировала и выводила их, как и раньше. Это подтвердит, что рефакторинг не сломал CLI.

### Задача 1.2: Рефакторинг логики воспроизведения

1.  **Создать сервис `player`**:
    *   Создать файл `internal/player/player.go`.
    *   Определить в нем структуру `Player`.
2.  **Перенести логику**:
    *   Перенести основную логику воспроизведения из `cmd/snatcher/play.go` в новый сервис `player`.
    *   Сервис `player` должен быть асинхронным. Его метод `Play(trackURL string)` должен запускать воспроизведение в горутине.
3.  **Реализовать обратную связь через каналы**:
    *   Сервис `player` должен предоставлять каналы для получения обновлений о своем состоянии:
        *   `Progress() <-chan PlayerStatus`: канал для отправки текущего прогресса, общей длительности и статуса (играет, на паузе).
        *   `Done() <-chan bool`: канал, который будет закрыт по завершении воспроизведения.
    *   Это ключевой шаг для интеграции с Bubble Tea.
4.  **Обновить команду `play`**:
    *   Изменить `cmd/snatcher/play.go`. Теперь команда `play` будет создавать экземпляр `player.Player`, запускать воспроизведение и в цикле `select` слушать каналы `Progress` и `Done` для вывода информации в консоль.

---

## Этап 2: Создание TUI с двумя экранами

**Цель:** Реализовать базовый TUI с навигацией между списком треков и экраном плеера.

### Задача 2.1: Настройка проекта

1.  **Добавить зависимости**:
    *   Выполнить `go get github.com/charmbracelet/bubbletea`
    *   Выполнить `go get github.com/charmbracelet/lipgloss`
2.  **Создать пакет `tui`**:
    *   Создать директорию `internal/tui`.
3.  **Создать новую команду `tui`**:
    *   В `cmd/snatcher/main.go` добавить новую команду `createTUICommand()`, которая будет запускать Bubble Tea приложение.

### Задача 2.2: Модель экрана списка треков

1.  **Создать пакет `tracklist`**:
    *   Создать директорию `internal/tui/tracklist`.
    *   В ней создать `model.go`.
2.  **Реализовать модель**:
    *   Модель будет использовать компонент `list.Model` из Bubble Tea.
    *   В `Init` или `Update` модель будет использовать `track.Manager` (из Этапа 1) для получения списка треков.
    *   Реализовать `View`, который будет отображать список.
    *   При нажатии `Enter` на элементе списка, модель должна отправлять сообщение `tea.Msg` (например, `tracklist.TrackSelectedMsg{TrackID: 123}`) для переключения на экран плеера.

### Задача 2.3: Модель экрана воспроизведения

1.  **Создать пакет `player` для TUI**:
    *   Создать директорию `internal/tui/player`.
    *   В ней создать `model.go`.
2.  **Реализовать модель**:
    *   Модель будет получать `TrackSelectedMsg` и хранить информацию о выбранном треке.
    *   Она будет использовать сервис `player.Player` (из Этапа 1) для запуска воспроизведения.
3.  **Интеграция с асинхронным плеером**:
    *   Модель должна запускать `tea.Cmd`, который в горутине будет слушать каналы `Progress` и `Done` сервиса `player.Player`.
    *   При получении данных из канала, горутина будет отправлять новые сообщения `tea.Msg` (например, `PlayerProgressMsg`, `PlaybackFinishedMsg`) в основной цикл TUI.
    *   Метод `Update` модели будет обрабатывать эти сообщения и обновлять состояние (например, значение в прогресс-баре).
4.  **Реализовать `View`**:
    *   Отображать информацию о треке, прогресс-бар, статус (▶️, ⏸️).
    *   Реализовать управление: `пробел` для паузы/возобновления, `q` или `esc` для возврата к списку треков (отправив сообщение `GoBackMsg`).

### Задача 2.4: Главная модель-роутер

1.  **Создать `internal/tui/tui.go`**:
    *   Реализовать главную модель, которая будет содержать в себе модели `tracklist` и `player`.
    *   Эта модель будет действовать как роутер: на основе сообщений (`TrackSelectedMsg`, `GoBackMsg`) она будет решать, какую дочернюю модель (`View`) отображать в данный момент.

---

## Этап 3: Дальнейшие шаги (будущее)

*   Рефакторинг оставшихся команд (`add`, `download`, `delete`) по аналогии с Этапом 1.
*   Интеграция функционала добавления, скачивания и удаления в TUI в виде новых экранов.
*   Добавление обработки ошибок и отображения уведомлений в TUI.